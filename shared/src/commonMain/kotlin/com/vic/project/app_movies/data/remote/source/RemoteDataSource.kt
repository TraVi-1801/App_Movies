package com.vic.project.app_movies.data.remote.sourceimport com.vic.project.app_movies.data.mapper.toDomainModelimport com.vic.project.app_movies.data.mapper.toDomainMovieDetailimport com.vic.project.app_movies.data.remote.error.ApiExceptionimport com.vic.project.app_movies.data.remote.service.MovieServiceimport com.vic.project.app_movies.domain.model.Movieimport com.vic.project.app_movies.domain.model.MovieDetailimport com.vic.project.app_movies.utils.Dispatcherimport com.vic.project.app_movies.utils.ResultWrapperimport kotlinx.coroutines.withContextinternal class RemoteDataSource(    private val apiService: MovieService,    private val dispatcher: Dispatcher) {    suspend fun getMovies(search: String): ResultWrapper<List<Movie>> =        safeApiCall {            val response = apiService.getMovies(search)            if (response.success == false) {                ResultWrapper.Error(response.status_message ?: "Unknown error")            } else {                ResultWrapper.Success(response.results.orEmpty().map { it.toDomainModel() })            }        }    suspend fun getMoviesTrending(): ResultWrapper<List<Movie>> =        safeApiCall {            val response = apiService.getMoviesTrending()            if (response.success == false) {                ResultWrapper.Error(response.status_message ?: "Unknown error")            } else {                ResultWrapper.Success(response.results.orEmpty().map { it.toDomainModel() })            }        }    suspend fun getMovie(movieId: Int): ResultWrapper<MovieDetail> =        safeApiCall {            val response = apiService.getMovie(movieId)            if (response.success == false) {                ResultWrapper.Error(response.status_message ?: "Unknown error")            } else {                ResultWrapper.Success(response.toDomainMovieDetail())            }        }    private suspend fun <T> safeApiCall(apiCall: suspend () -> ResultWrapper<T>): ResultWrapper<T> {        return withContext(dispatcher.io) {            try {                apiCall()            } catch (e: ApiException) {                when (e) {                    is ApiException.NetworkUnavailable -> ResultWrapper.Error("No internet. Please check your connection.")                    is ApiException.Timeout -> ResultWrapper.Error("Request timed out. Try again later.")                    is ApiException.HttpError -> ResultWrapper.Error("Server error ${e.code}")                    else -> ResultWrapper.Error("Something went wrong. Try again.")                }            }        }    }}