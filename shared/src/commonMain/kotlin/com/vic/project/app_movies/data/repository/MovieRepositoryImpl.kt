package com.vic.project.app_movies.data.repositoryimport com.vic.project.app_movies.data.local.source.LocalDataSourceimport com.vic.project.app_movies.data.remote.source.RemoteDataSourceimport com.vic.project.app_movies.domain.model.Movieimport com.vic.project.app_movies.domain.model.MovieDetailimport com.vic.project.app_movies.domain.repository.MovieRepositoryimport com.vic.project.app_movies.utils.Dispatcherimport com.vic.project.app_movies.utils.Loggerimport com.vic.project.app_movies.utils.ResultWrapperimport com.vic.project.app_movies.utils.TimeUtils.isNotTodayimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport kotlinx.coroutines.flow.onStartimport kotlin.time.Clockimport kotlin.time.ExperimentalTimeinternal class MovieRepositoryImpl(    private val remoteDateSource: RemoteDataSource,    private val localDataSource: LocalDataSource,    private val dispatcher: Dispatcher,    private val logger: Logger) : MovieRepository {    @OptIn(ExperimentalTime::class)    override suspend fun getTrendingMovies(): Flow<ResultWrapper<List<Movie>>> = flow {        val localMovies = localDataSource.getTrendingMovies()        val timestamp = localDataSource.getTrendingMoviesTimestamp()        val shouldFetchRemote = timestamp == null || timestamp.isNotToday()        if (localMovies.isNotEmpty()) {            emit(ResultWrapper.Success(localMovies))        } else {            emit(ResultWrapper.Loading)        }        if (shouldFetchRemote) {            logger.d("Repo", "Fetching trending movies from remote")            val remoteMovies = remoteDateSource.getMoviesTrending()            if (remoteMovies is ResultWrapper.Success) {                localDataSource.saveTrendingMovies(                    Clock.System.now().toEpochMilliseconds(), remoteMovies.data                )            }            emit(remoteMovies)        }    }.catch { e ->        emit(ResultWrapper.Error(e.message))    }    override suspend fun searchMovies(search: String): Flow<ResultWrapper<List<Movie>>> =        wrapWithLoading {            remoteDateSource.getMovies(search)        }    override suspend fun getMovie(movieId: Int): Flow<ResultWrapper<MovieDetail>> = flow {        val localMovie = localDataSource.getMovieDetail(movieId)        if (localMovie != null) {            emit(ResultWrapper.Success(localMovie))        } else {            emit(ResultWrapper.Loading)            val remoteMovie = remoteDateSource.getMovie(movieId)            if (remoteMovie is ResultWrapper.Success) {                localDataSource.saveMovieDetail(remoteMovie.data)            }            emit(remoteMovie)        }    }.catch { e ->        emit(ResultWrapper.Error(e.message))    }    private fun <T> wrapWithLoading(apiCall: suspend () -> ResultWrapper<T>): Flow<ResultWrapper<T>> {        return flow {            emit(apiCall())        }.onStart {            emit(ResultWrapper.Loading)        }.flowOn(dispatcher.io)    }}